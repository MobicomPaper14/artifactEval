'''
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

Created by: Om Chabra
Created on: 17 March 2023
@desc
    This module implements the creation of data. 
'''
import numpy as np
import queue

from src.simlogging.ilogger import ELogType, ILogger
from src.nodes.inode import INode
from src.models.imodel import IModel, EModelTag

from src.models.network.data.sensorappdata import SensorAppData

class ModelDataGenerator(IModel):
    
    __modeltag = EModelTag.DATAGENERATOR
    __ownernode: INode
    __supportednodeclasses = []
    __dependencies = []  
    __logger: ILogger

    
    @property
    def iName(self) -> str:
        """
        @type 
            str
        @desc
            A string representing the name of the model class. For example, ModelPower 
            Note that the name should exactly match to your class name. 
        """
        return self.__class__.__name__
    
    @property
    def modelTag(self) -> EModelTag:
        """
        @type
            EModelTag
        @desc
            The model tag for the implemented model
        """
        return self.__modeltag

    @property
    def ownerNode(self):
        """
        @type
            INode
        @desc
            Instance of the owner node that incorporates this model instance.
            The subclass (implementing a model) should keep a private variable holding the owner node instance. 
            This method can return that variable.
        """
        return self.__ownernode
    
    @property
    def supportedNodeClasses(self) -> 'list[str]':
        '''
        @type
            List of string
        @desc
            A model may not support all the node implementation. 
            supportedNodeClasses gives the list of names of the node implementation classes that it supports.
            For example, if a model supports only the SatBasic and SatAdvanced, the list should be ['SatBasic', 'SatAdvanced']
            If the model supports all the node implementations, just keep the list EMPTY.
        '''
        return self.__supportednodeclasses
    
    @property
    def dependencyModelClasses(self) -> 'list[list[str]]':
        '''
        @type
            Nested list of string
        @desc
            dependencyModelClasses gives the nested list of name of the model implementations that this model has dependency on.
            For example, if a model has dependency on the ModelPower and ModelOrbitalBasic, the list should be [['ModelPower'], ['ModelOrbitalBasic']].
            Now, if the model can work with EITHER of the ModelOrbitalBasic OR ModelOrbitalAdvanced, the these two should come under one sublist looking like [['ModelPower'], ['ModelOrbitalBasic', 'ModelOrbitalAdvanced']]. 
            So each exclusively dependent model should be in a separate sublist and all the models that can work with either of the dependent models should be in the same sublist.
            If your model does not have any dependency, just keep the list EMPTY. 
        '''
        return self.__dependencies
    
    def __str__(self) -> str:
        return "".join(["Model name: ", self.iName, ", " , "Model tag: ", self.__modeltag.__str__()])
    
    def __stop_Generating(self,** _kwargs):
        '''
        @desc
            This method stops the model from generating any more data
        @param[in] _kwargs
            Keyworded arguments
            None 
        @return
            None
        '''
        self.__logger.write_Log(f"Stopping Data Creation for {self.__ownernode.iName}", ELogType.LOGDEBUG, self.__ownernode.timestamp)
        self.__dataPoissonLambda = 0
    
    def __get_Data(self, **_kwargs):
        '''
        @desc
            This method returns the data generated by the model
        @param[in] _kwargs
            Keyworded arguments
            None 
        @return
            Data if available, None otherwise
        '''
        if self.__dataQueueLength == 0:
            return None
        _ret = self.__dataQueue.get()
        self.__dataQueueLength -= 1
        return _ret
    
    def __get_Queue(self, **_kwargs):
        """
        @desc
            This method returns the data queue of the model
        @param[in] _kwargs
            Keyworded arguments
            None
        @return
            Data queue
        """
        return self.__dataQueue
    
    def __get_QueueSize(self, **_kwargs):
        """
        @desc
            This method returns the size of the data queue of the model
        @param[in] _kwargs
            Keyworded arguments
            None
        @return
            Size of the data queue
        """
        return self.__dataQueueLength
            
    # API dictionary where API name is the key and handler function is the value
    __apiHandlerDictionary = {
        "stop": __stop_Generating,
        "get_Data": __get_Data,
        "get_Queue": __get_Queue,
        "get_QueueSize": __get_QueueSize,
    }
    
    def call_APIs(
            self, 
            _apiName: str, 
            **_kwargs):
        '''
        This method acts as an API interface of the model. 
        An API offered by the model can be invoked through this method.
        @param[in] _apiName
            Name of the API. Each model should have a list of the API names.
        @param[in]  _kwargs
            Keyworded arguments that are passed to the corresponding API handler
        @return
            The API return
        This model does not have any API. So, this method does nothing.
        '''
        _ret = None

        try:
            _ret = self.__apiHandlerDictionary[_apiName](self, **_kwargs)
        except Exception as e:
            print(f"[ModelDataGenerator]: An unhandled API request has been received by {self.__ownernode.nodeID}:", e)
        
        return _ret
    
    def __log_Message(self, _data: 'GenericData', _event: 'str'):
        """
        @desc
            This method logs a message for the given
        @param[in] _data
            Data to be logged
        @param[in] _event
            Event to be logged 
        """
        self.__logger.write_Log(_event + f" dataID: {_data.id}. " +
            f"queueSize: {self.__get_QueueSize()}" \
            , ELogType.LOGINFO, self.__ownernode.timestamp, self.iName)
    
    def Execute(self):
        '''
        @desc
            This method creates a respective number of data objects and sends them to the radio model
        '''
        # get the simulator epoch delta
        _timeDelta = self.__ownernode.deltaTime

        _numData = np.random.poisson(_timeDelta * self.__dataPoissonLambda) # each second, we expect to generate __dataPoissonLambda data points

        _numData = int(round(_numData))
        if _numData > 0:   
            #now try to create and send data to the radio model
            for _ in range(_numData):
                _dataToSend = SensorAppData(
                                        sourceNodeID=f"{self.__ownernode.nodeID}",
                                        size=self.__dataSize,
                                        creationTime=self.__ownernode.timestamp.copy())
                
                if not self.__selfCtrl:
                    if not self.__dataQueueLength == self.__maxQueueSize:
                        self.__dataQueue.put(_dataToSend)
                        self.__dataQueueLength += 1
                        self.__log_Message(_dataToSend, "Generated")
                    else:
                        self.__log_Message(_dataToSend, "Dropped")
                else:
                    _loraModel = self.__ownernode.has_ModelWithTag(EModelTag.BASICLORARADIO)
                    _loraModel.call_APIs("add_DataToTransmit", _data = _dataToSend)
                    self.__log_Message(_dataToSend, "Generated")
    def __init__(
            self, 
            _ownernodeins: INode, 
            _loggerins: ILogger,
            _dataPoissonLambda: float,
            _dataSize: int,
            _queueSize: int,
            _selfCtrl: bool) -> None:
        '''
        @desc
            Constructor of the class
        @param[in]  _ownernodeins
            Instance of the owner node that incorporates this model instance
        @param[in]  _loggerins
            Logger instance
        @param[in] _dataPoissonLambda
            Lamda value of poisson distribution representing number of data to be generated per second
        @param[in] _dataSize
            How large the data created should be
        @param[in] _queueSize
            Size of the data queue
        @param[in] _selfCtrl
            If the model is self controlled or not. In this case, if the model is self controlled, it will send automatically data to the radio model
        '''
        self.__ownernode = _ownernodeins
        self.__logger = _loggerins
        
        self.__dataPoissonLambda = _dataPoissonLambda
        
        self.__dataSize = _dataSize
        
        self.__dataQueue = queue.Queue(maxsize=_queueSize)
        self.__dataQueueLength = 0 # a variable to keep track of the queue length. Less overhead than calling qsize() every time
        self.__maxQueueSize = _queueSize
        
        self.__selfCtrl = _selfCtrl
        
def init_ModelDataGenerator(
    _ownernodeins: INode, 
    _loggerins: ILogger, 
    _modelArgs) -> IModel:
    """
    @desc
        This method initializes an instance of the ModelDataGenerator
    @param[in]  _ownernodeins
        Instance of the owner node that incorporates this model instance
    @param[in]  _loggerins
        Logger instance
    @param[in]  _modelArgs
        It's a converted JSON object containing the model related info. 
        @key data_poisson_lambda
            The lambda value of the poisson distribution representing the number of data to be generated per second
        @key data_size
            How large the data created should be
        @key queue_size
            Size of the data queue. Default is -1, which means infinite
        @key self_ctrl
            Wether to automatically push data to the radio model or not. Default is False
    @return
        Instance of the model class
    """
    _queueSize = -1
    if 'queue_size' in _modelArgs:
        _queueSize = _modelArgs.queue_size
        
    if "self_ctrl" in _modelArgs:
        _selfCtrl = _modelArgs.self_ctrl
    else:
        _selfCtrl = False
    
    return ModelDataGenerator(
                        _ownernodeins, 
                        _loggerins, 
                        _modelArgs.data_poisson_lambda, 
                        _modelArgs.data_size,
                        _queueSize,
                        _selfCtrl)
