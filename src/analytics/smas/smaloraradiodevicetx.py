'''
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

Created by: Om Chabra
Created on: 14 Jul 2023
@desc
    This module analyzes the logs generated by the LoraRadioDevice and produces a table describing the transmission of packets in the specified format:

        1. frameID
        2. sourceAddress
        3. frameSize
        4. payloadSize
        5. mtuDrop
        6. busyDrop
        7. noValidChannelDrop
        8. instanceIDs
        9. destinationNodeIDs
        10. destinationRadioIDs
        11. snrs
        12. secondsToTransmits
        13. plrs
        14. pers
        15. timestamp
        16. nodeID
    It exclusively processes the "tx" message of the LoraRadioDevice in the following format:
    "Transmitting. frameID: {int}. sourceAddress: {addr}. frameSize: {int}. payloadSize: {int}. mtuDrop: {bool}. busyDrop: {bool}. noValidChannelDrop: {bool}.
    instanceIDs: {listOfInts}. destinationNodeIDs: {listOfInts}. destinationRadioIDs: {listOfInts}. snrs: {listOfFloats}. secondsToTransmits: {listOfFloats}.
    plrs: {listOfFloats}. pers: {listOfFloats}."
    (Note: The brackets in the log message are placeholders to indicate the actual values that will replace them.)
'''

from src.analytics.smas.isma import ISMA
import dask.dataframe as dd
import dask
from pandas import DataFrame

class SMALoraRadioDeviceTx(ISMA):
    __supportedSMANames = [] # No dependency on any other SMA
    __supportedModelNames = ['LoraRadioDevice'] # Dependency on the class in this case. 
    
    @property
    def iName(self) -> str:
        """
        @type 
            str
        @desc
            A string representing the name of the SMA class. For example, smapower 
            Note that the name should exactly match to your class name. 
        """
        return self.__class__.__name__

    @property
    def supportedModelNames(self) -> 'list[str]':
        '''
        @type
            String
        @desc
           supportedModelNames gives the list of name of the models, the log of which this SMA can process.
        '''
        return self.__supportedModelNames
    
    @property
    def supportedSMANames(self) -> 'list[str]':
        '''
        @type
            String
        @desc
            supportedSMANames gives the list of name of the SMAs, the output of which this SMA can process.
        '''
        return self.__supportedSMANames

    def call_APIs(
            self, 
            _apiName: str, 
            **_kwargs):
        '''
        This method acts as an API interface of the SMA. 
        An API offered by the SMA can be invoked through this method.
        @param[in] _apiName
            Name of the API. Each SMA should have a list of the API names.
        @param[in]  _kwargs
            Keyworded arguments that are passed to the corresponding API handler
        @return
            The API return
        '''
        pass

    def Execute(self):
        """
        This method executes the tasks that needed to be performed by the SMA.
        """
        #let's read the whole log file. Let's use dask because this log file might be huge
        _logData = dd.read_csv(self.__logFile, quotechar='"', delimiter=',', skipinitialspace=True)
        
        #we should have the following columns: logLevel, timestamp, modelName, message
        #We only need the ones where modelName matches our dependencyModelName
        _modelLogData = _logData[_logData['modelName'] == "LoraRadioDevice"]
        
        #I'm going to create two regexes & dataframes. One for the receiving log message and one for the transmitting log message
        #This is regex for a list of floats. It also includes scientific notation. g is the name of the column
        _word = lambda g: "(?P<" + g + ">[\w]+)"
        _listOfInts = lambda g: r'\[(?P<' + g+ r'>[\d, ]*)\]'
        _listOfFloats = lambda g: "\[(?P<" + g + '>[-+]?\d+(?:\.\d+)?(?:e[-+]?\d+)?(?:,\s*[-+]?\d+(?:\.\d+)?(?:e[-+]?\d+)?)*)\]'
        
        #This is all one line. I'm going to break it up into multiple lines for readability
        _txRegex = f"Transmitting\. " + \
            "frameID: {}. ".format(_word('frameID')) + \
            "sourceAddress: {}. ".format(_word('sourceAddress')) + \
            "frameSize: {}. ".format(_word('frameSize')) +\
            "payloadSize: {}. ".format(_word('payloadSize')) +\
            "mtuDrop: {}. ".format(_word('mtuDrop'))  + \
            "busyDrop: {}. ".format(_word('busyDrop')) + \
            "noValidChannelDrop: {}. ".format(_word('noValidChannelDrop')) + \
            "instanceIDs: {}. ".format(_listOfInts('instanceIDs')) + \
            "destinationNodeIDs: {}. ".format(_listOfInts('destinationNodeIDs')) + \
            "destinationRadioIDs: {}. ".format(_listOfInts('destinationRadioIDs')) + \
            "snrs: {}. ".format(_listOfFloats('snrs')) + \
            "secondsToTransmits: {}. ".format(_listOfFloats('secondsToTransmits')) + \
            "plrs: {}. ".format(_listOfFloats('plrs')) + \
            "pers: {}. ".format(_listOfFloats('pers'))

        _txInfo = _modelLogData['message'].str.extract(_txRegex)
        #Let's add in the timestamp and the nodeID. We do it now because the index is going to be reset later
        _txInfo['timestamp'] = _modelLogData['timestamp']
        _txInfo['nodeID'] = self.__nodeID
        
        #drop the rows which the regex didn't match
        _txInfo = _txInfo.dropna()   
        
        #Let's convert it to a pandas dataframe
        #Let's hope that the data is small enough to fit into memory
        _df = _txInfo.compute()
        
        #Let's make the booleans into actual booleans
        _boolKeys = ['mtuDrop', 'busyDrop', 'noValidChannelDrop']
        for _key in _boolKeys:
            _df[_key] = _df[_key].map({'True': True, 'False': False})
        
        #Let's make the lists into actual lists
        _intKeys = ['instanceIDs', 'destinationNodeIDs', 'destinationRadioIDs']
        for _key in _intKeys:
            _df[_key] = _df[_key].str.split(',').apply(lambda x: [int(_x) for _x in x])
            
        _floatKeys = ['snrs', 'secondsToTransmits', 'plrs', 'pers']
        for _key in _floatKeys:
            _df[_key] = _df[_key].str.split(',').apply(lambda x: [float(_x) for _x in x])

        #Let's now make everything to the right types
        _dataTypes = {
            'frameID': 'int64',
            'sourceAddress': 'int64',
            'frameSize': 'int64',
            'payloadSize': 'int64',
            'mtuDrop': 'bool',
            'busyDrop': 'bool',
            'noValidChannelDrop': 'bool',
            'instanceIDs': 'object',
            'destinationNodeIDs': 'object',
            'destinationRadioIDs': 'object',
            'snrs': 'object',
            'secondsToTransmits': 'object',
            'plrs': 'object',
            'pers': 'object',
            'timestamp': 'datetime64[ns]',
            'nodeID': 'int64',
        }

        #Let's now convert the types. Ignore any NaNs
        _results = _df.astype(_dataTypes)
        
        #Also, reset the index
        _results = _results.reset_index(drop=True)
        
        self.__results = _results

    def get_Results(self) -> DataFrame:
        '''
        @desc
            This method returns the results of the SMA in the form of a DataFrame table once it is executed.
        @return
            A DataFrame table containing the results of the SMA.
        '''
        return self.__results

    def __init__(self,
                 _modelLogPath: str):
        '''
        @desc
            Constructor
        @param[in] _modelLogPath
            Path to the log file of the model
        '''
        self.__logFile = _modelLogPath
        self.__nodeID = self.__logFile.split('/')[-1].split('_')[-1].split('.')[0] #get the nodeID from the log file name
        self.__results = None

def init_SMALoraRadioDeviceTx(**_kwargs) -> ISMA:
    '''
    @desc
        Initializes the SMALoraRadioDeviceTx class
    @param[in] _kwargs
        Keyworded arguments that are passed to the constructor of the SMALoraRadioDeviceTx class.
        It should have the following (key, value) pairs:
        @key modelLogPath
            Path to the log file of the model
    @return
        An instance of the SMALoraRadioDeviceTx class
    '''
    if 'modelLogPath' not in _kwargs:
        raise Exception('[Simulator Exception] The keyworded argument modelLogPath is missing')
    
    #create an instance of the SMADataGenerator class
    _sma = SMALoraRadioDeviceTx(_kwargs['modelLogPath'])
    return _sma
